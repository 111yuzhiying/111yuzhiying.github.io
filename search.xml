<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++对象的一些知识点</title>
      <link href="/2023/03/23/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/23/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="让字符指针指向string时，需要将string-0-的地址赋给字符指针"><a href="#让字符指针指向string时，需要将string-0-的地址赋给字符指针" class="headerlink" title="让字符指针指向string时，需要将string[0]的地址赋给字符指针"></a>让字符指针指向string时，需要将string[0]的地址赋给字符指针</h3><p>下面的例子就是样例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;hello wordla!&quot;;</span><br><span class="line">    char *p;</span><br><span class="line">    p = &amp;s[0];</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以遇到带参的构造函数时，如果遇到形参为（char*）的，对应想要传进去的字符串，直接 &amp;对应字符串[0]， 就可以了。</p><h3 id="关于strcpy-s的一个问题"><a href="#关于strcpy-s的一个问题" class="headerlink" title="关于strcpy_s的一个问题"></a>关于strcpy_s的一个问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char s1[]=&quot;hello&quot;;</span><br><span class="line">    char s2[]=&quot;world&quot;;</span><br><span class="line">    char s3[20];</span><br><span class="line">    strcpy_s(s3,2,s2);</span><br><span class="line">    cout&lt;&lt;s3;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话因为字节长度是明显的小于strlen(s2)时,是不够空间的，所以赋值是失败的，无法进行复制，故会发现输出null，无输出内容</p><h3 id="面向对象的遇到的类内声明中对private数据的调用"><a href="#面向对象的遇到的类内声明中对private数据的调用" class="headerlink" title="面向对象的遇到的类内声明中对private数据的调用"></a>面向对象的遇到的类内声明中对private数据的调用</h3><pre><code>今天翻看C++课件，发现有趣的东西</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CComplex&#123;</span><br><span class="line">public:</span><br><span class="line">         void output()</span><br><span class="line">&#123;  cout&lt;&lt;real;</span><br><span class="line">    cout&lt;&lt;image;  &#125;</span><br><span class="line"></span><br><span class="line">         double get_real() </span><br><span class="line">        &#123;   return real;   &#125;</span><br><span class="line">        double get_image()  </span><br><span class="line">        &#123;   return image；&#125;</span><br><span class="line">        void reset(double r,double i)</span><br><span class="line">        &#123;   real=r;   image=i;  &#125;</span><br><span class="line"></span><br><span class="line">       CComplex add( CComplex c2)</span><br><span class="line">      &#123;  CComplex  c;</span><br><span class="line">         c.real=real+c2.real;</span><br><span class="line">         c.image=image+c2.image;</span><br><span class="line">        return c; &#125;</span><br><span class="line">private:</span><br><span class="line">double real;</span><br><span class="line">double image;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当时一开始看到这个时，心想是不是有错误的，因为看到add函数中对新建的对象的私有成员数据进行了直接的调用与赋值（但real、image不是对象的私有成员吗？），而且这也没有用friend友元函数进行声明，会不会是错误的？于是，作为蒟蒻的我上网查找资料，发现原来是要靠咬文嚼字来进行理解的。<br>解释：在类的成员函数中可以访问本类的私有数据，即使是通过函数参数传入的本类的另一个对象的私有数据，也可以正常访问，即“本类的私有数据”由所有本类的对象的私有数据组成。但是在A类中无法直接访问B类的私有数据，但可以通过友元类实现。<br>    说人话：就是在类中定义的函数对数据成员来说是可以调用的。</p><p>###函数的参数里面有const限定时，函数的表示形式<br>    当所调用的函数里面有const数据时，其函数要在末尾加上const标识符，暗示函数是常函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyString strcpy1( const MyString &amp;s1) ;</span><br></pre></td></tr></table></figure><p>上述代码中形参用了const型数据，但是没有在末尾加上const标识符，编译系统会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passing &#x27;const MyString&#x27; as &#x27;this&#x27; argument discards qualifiers [-fpermissive]</span><br></pre></td></tr></table></figure><p>因此正确的操作应为这样子的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyString strcpy1( const MyString &amp;s1) const;</span><br></pre></td></tr></table></figure><p>网上查到的解释是：传进去的const数据是不能够被更改的，当函数没有标识为const并且实际没有对const数据进行改动时，系统还是认为这个函数对const数据进行了改动，因此，在函数的声明以及定义处还是要加上const限定符才可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蒟蒻学算法</title>
      <link href="/2023/03/23/git-bash/"/>
      <url>/2023/03/23/git-bash/</url>
      
        <content type="html"><![CDATA[<p>今天遇到一题算法题，涉及到排序sort的bool判断值，如果能用到多重排序，题目就会好解很多。<br>其题目是这样的：</p><p>…….明早再补了<br>[<img src="https://s1.ax1x.com/2023/03/28/ppyImcQ.png" alt="ppyImcQ.png"></p><p>先上AC代码块：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 7;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    long long a,w;</span><br><span class="line">&#125;node [N];</span><br><span class="line">long long n,sum,ans;</span><br><span class="line">bool cmp(NODE n1, NODE n2)&#123;</span><br><span class="line">    if(n1.a &lt; n2.a) return true;</span><br><span class="line">    if(n1.a == n2.a &amp;&amp; n1.w &lt;= n2.w) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;node[i].a&gt;&gt;node[i].w;</span><br><span class="line">        sum += node[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node + 1,node+n+1,cmp);</span><br><span class="line">    NODE temp = node[0];</span><br><span class="line">    for(int i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        if(node[i].a != temp.a)</span><br><span class="line">            ans += temp.w;</span><br><span class="line">        temp = node[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum - ans;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort排序中的自定义排序需要头文件&lt;algorithm&gt;<br>bool cmp()函数名只是便于知道这是一个比较函数，通过所返回的bool值来实行具体的排序顺序，其名字可以随意，只要满足是bool类型返回值以及符合变量命名规则即可。</p><p>sort排序中默认的排序规则是从小到大，是升序排序。那么如何改变这一默认排序规则呢？<br>举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool cmp(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑是：sort排序默认是a&amp;ltb是返回true的布尔值，而这里返回a&amp;gtb,则返回false与默认的true所矛盾，因此需要改变默认的排序方式。其实就是有一个简单的记忆方法————将想要进行的排序return true，不想的排序则返回false即可。需要注意的是，return 即代表函数的结束，函数体内剩下没执行的代码则会被忽略掉。</p><p>结构体也可以根据其成员数据进行排序，举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(node x,node y)&#123;   //传入两个结构体对象</span><br><span class="line">    if(x.a!=y.a) return x.a&lt;y.a;</span><br><span class="line">    if(x.b!=y.b) return x.b&gt;y.b;</span><br><span class="line">    if(x.c!=y.c) return x.c&lt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里定义的cmp是先按照a进行升序排序，如果a相同的话对b及逆行降序排序，如果两个结构体中a、b数据成员均相等的话，就以数据成员c进行升序排序。</p><p>而对于本题而言，其实也是根据结构体内部的数据进行排序，先利用其用数字来代表课的种类，因此可以根据课的种类对课程先进行一个升序排序，让同一种课能够在连续的一段，然后在课程的内部再进行升序排序。这样的话，在一种课的类别的最后就是该课程的最大疲劳度，再利用for循环对其最后端进行累加得到各个类别课的疲劳度的最大值的累加和ans。到这里只需在一开始输入的时候累加各门课的疲劳度即可得到总疲劳度sum，最后总疲劳度sum减去最大疲劳度累加和ans即可得到答案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/23/hello-world/"/>
      <url>/2023/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
